#!/usr/bin/env python
"""
mbank_run
---------

A script to run mbank for generating a bank

To generate a bank:

	mbank_run --options-you-like

You can also load (some) options from an ini-file:

	mbank_run --some-options other_options.ini

Make sure that the mbank is properly installed.
To know which options are available:

	mbank_run --help
"""
import numpy as np
import matplotlib.pyplot as plt
import sys
import pickle
import lal.series
from ligo.lw.utils import load_filename

from mbank import variable_handler, cbc_metric, cbc_bank
from mbank.utils import updates_args_from_ini, int_tuple_type, load_PSD, avg_dist, plot_tiles_templates

import argparse
import os

def int_tuple_type(strings):
	strings = strings.replace("(", "").replace(")", "")
	mapped_int = map(int, strings.split(","))
	return tuple(mapped_int)


##### Creating parser
parser = argparse.ArgumentParser(__doc__)
parser.add_argument(
	"--variable-format", required = False,
	help="Choose which variables to include in the bank. Valid formats are those of `mbank.handlers.variable_format`")
parser.add_argument(
	"--mm", required = False, type = float, default = 0.97,
	help="Minimum match for the bank (a.k.a. average distance between templates)")
parser.add_argument(
	"--psd",  required = False,
	help="The input file for the PSD: it can be either a txt either a ligolw xml file")
parser.add_argument(
	"--asd",  default = False, action='store_true',
	help="Whether the input file has an ASD (sqrt of the PSD)")
parser.add_argument(
	"--ifo", default = 'L1', type=str, choices = ['L1', 'H1', 'V1'],
	help="Interferometer name: it can be L1, H1, V1. This is a field for the xml files for the PSD and the bank")
parser.add_argument(
	"--plot", action='store_true',
	help="Whether to make some plots. They will be store in run-dir")
parser.add_argument(
	"--show", action='store_true',
	help="Whether to show the plots.")
parser.add_argument(
	"--run-dir", default = './out_$(run_name)',
	help="Output directory in which the bank will be saved. If default is used, the bank name will be appended.")
parser.add_argument(
	"--run-name", default = 'cbc_mbank',
	help="Name for the bank output file")
parser.add_argument(
	"--grid-size", default = None, type=int_tuple_type,
	help="Number of grid points for each dimension. The number of grid must match the number extra dimensions. If None, the grid size will be a set of ones")
parser.add_argument(
	"--f-min",  default = 10., type=float,
	help="Minium frequency for the scalar product")
parser.add_argument(
	"--f-max",  default = 1024., type=float,
	help="Maximum frequency for the scalar product")
parser.add_argument(
	"--approximant", default = None,
	help="LAL approximant for the bank generation")
parser.add_argument(
	"--placing-method", default = 'geometric', type = str, choices = cbc_bank('Mq_nonspinning').placing_methods,
	help="Which placing method to use for each tile")
parser.add_argument(
	"--v-tile", default = 200, type = float,
	help="Maximum volume for each tile. The volume is normalized by 0.1^D. This is equivalent to the number of templates in each tile, assuming a constant reference metric distance between them of 0.1.")
parser.add_argument(
	"--use-ray", action='store_true', default = False,
	help="Whether to use ray package to parallelize the metric computation")
	
	#ranges for physical parameters
parser.add_argument(
	"--m-range", default = [10., 100], type=float, nargs = 2,
	help="Range values for the masses (in solar masses)")
parser.add_argument(
	"--mtot-range", default = [10., 100], type=float, nargs = 2,
	help="Range values for the total masses (in solar masses).")
parser.add_argument(
	"--q-range", default = [1., 10.], type=float, nargs = 2,
	help="Range values for the mass ratio.")
parser.add_argument(
	"--mc-range", default = [10., 100], type=float, nargs = 2,
	help="Range values for the total masses (in solar masses).")
parser.add_argument(
	"--eta-range", default = [.18, .25], type=float, nargs = 2,
	help="Range values for the mass ratio.")
parser.add_argument(
	"--s1-range", default = [-0.8,0.8], type=float, nargs = 2,
	help="Range values for magnitude of spin 1 (if applicable)")
parser.add_argument(
	"--s2-range", default = [-0.8,0.8], type=float, nargs = 2,
	help="Range values for magnitude of spin 1 (if applicable)")
parser.add_argument(
	"--theta-range", default = [0., np.pi], type=float, nargs = 2,
	help="Range values for theta angles of spins (if applicable)")
parser.add_argument(
	"--phi-range", default = [-np.pi, np.pi], type=float, nargs = 2,
	help="Range values for phi angles of spins (if applicable)")
parser.add_argument(
	"--e-range", default = [0., 0.5], type=float, nargs = 2,
	help="Range values for the eccentricity (if applicable)")
parser.add_argument(
	"--meanano-range", default = [0., 1], type=float, nargs = 2,
	help="Range values for the mean anomaly (if applicable). TODO: find a nice default...")
parser.add_argument(
	"--iota-range", default = [0., np.pi], type=float, nargs = 2,
	help="Range values for iota (if applicable)")
parser.add_argument(
	"--ref-phase-range", default = [-np.pi, np.pi], type=float, nargs = 2,
	help="Range values for reference phase (if applicable)")

args, filenames = parser.parse_known_args()

	#updating from the ini file(s), if it's the case
for f in filenames:
	args = updates_args_from_ini(f, args, parser)

####################################################################################################
	######
	#	Interpreting the parser and initializing variables
	######

if (args.psd is None) or (args.mm is None) or (args.variable_format is None):
	raise ValueError("The arguments mm, psd and variable_format must be set!")

var_handler = variable_handler()
assert args.variable_format in var_handler.valid_formats, "Wrong value {} for variable-format".format(args.variable_format)

if args.run_dir == './out_$(run_name)':	args.run_dir = './out_{}/'.format(args.run_name)
if not args.run_dir.endswith('/'): args.run_dir = args.run_dir+'/'
if not os.path.exists(args.run_dir): os.makedirs(args.run_dir)
if args.psd.find('/') <0: args.psd = args.run_dir+args.psd

if args.grid_size is None: args.grid_size = tuple([1 for i in range(var_handler.D(args.variable_format))])

m_min, m_max = args.m_range
mtot_min, mtot_max = args.mtot_range
q_min, q_max = args.q_range
mc_min, mc_max = args.mc_range
eta_min, eta_max = args.eta_range
s1_min, s1_max = args.s1_range
s2_min, s2_max = args.s2_range
theta_min, theta_max = args.theta_range
e_min, e_max = args.e_range
meanano_min, meanano_max = args.meanano_range
phi_min, phi_max = args.phi_range
iota_min, iota_max = args.iota_range
ref_phase_min, ref_phase_max = args.ref_phase_range

plot_folder = None
if args.plot: plot_folder = args.run_dir

format_info = var_handler.format_info[args.variable_format]

	######
	#	Setting boundaries: shape (2,D)
	######
	#setting mass boundaries
if format_info['mass_format'] == 'm1m2':
	var1_min, var1_max = m_min, m_max
	var2_min, var2_max = m_min, m_max
elif format_info['mass_format'] == 'Mq':
	var1_min, var1_max = mtot_min, mtot_max
	var2_min, var2_max = q_min, q_max
elif format_info['mass_format'] == 'mceta':
	var1_min, var1_max = mc_min, mc_max
	var2_min, var2_max = eta_min, eta_max

	#setting spin boundaries
if format_info['spin_format'] == 'nonspinning':
	boundaries = np.array([[var1_min, var2_min],[var1_max, var2_max]])
elif format_info['spin_format'] == 's1z_s2z':
	boundaries = np.array([[var1_min, var2_min, s1_min, s2_min],[var1_max, var2_max, s1_max, s2_max]])
elif format_info['spin_format'] == 's1xz':
	boundaries = np.array([[var1_min, var2_min, s1_min, theta_min],[var1_max, var2_max, s1_max, theta_max]])
elif format_info['spin_format'] == 's1xyz':
	boundaries = np.array([[var1_min, var2_min, s1_min, theta_min, phi_min],[var1_max, var2_max, s1_max, theta_max, phi_max]])
elif format_info['spin_format'] == 's1xz_s2z':
	boundaries = np.array([[var1_min, var2_min, s1_min, theta_min, s2_min],[var1_max, var2_max, s1_max, theta_max, s2_max]])
elif format_info['spin_format'] == 's1xyz_s2z':
	boundaries = np.array([[var1_min, var2_min, s1_min, theta_min, phi_min, s2_min],[var1_max, var2_max, s1_max, theta_max, phi_max, s2_max]])
elif format_info['spin_format'] == 'fullspins':
	boundaries = np.array([[var1_min, var2_min, s1_min, theta_min, phi_min, s2_min, theta_min, phi_min,],[var1_max, var2_max, s1_max, theta_max, phi_max, s2_max, theta_max, phi_max]])
else:
	raise RuntimeError("Boundaries current not implemented for the required format of spins {}: apologies :(".format(format_info['spin_format']))

if format_info['e']:
	boundaries = np.concatenate([boundaries, [[e_min], [e_max]]], axis =1)
if format_info['meanano']:
	boundaries = np.concatenate([boundaries, [[meanano_min], [meanano_max]]], axis =1)
if format_info['iota']:
	boundaries = np.concatenate([boundaries, [[iota_min], [iota_max]]], axis =1)
if format_info['phi']:
	boundaries = np.concatenate([boundaries, [[ref_phase_min], [ref_phase_max]]], axis =1)

	######
	#	Loading PSD and initializing metric
	######
m = cbc_metric(args.variable_format,
			PSD = load_PSD(args.psd, args.asd, args.ifo),
			approx = args.approximant,
			f_min = args.f_min, f_max = args.f_max)

print("## Running: ", args.run_name)

	######
	#	Running and saving the output
	######
bank = cbc_bank(args.variable_format)

if format_info['mass_format'] == 'm1m2':
	raise NotImplementedError("Currently no template placement is implemented for the mass format m1m2.")

if format_info['mass_format'] == 'Mq' or format_info['mass_format'] == 'mceta':
	
	t_obj, tile_id_population = bank.generate_bank(m, avg_match = args.mm, boundaries = boundaries, V_tile = args.v_tile,
		grid_list = args.grid_size, placing_method = args.placing_method, use_ray = args.use_ray)
	
	t_obj.save(args.run_dir+'tiling_{}.npy'.format(args.run_name)) #storing the tiling in the out_folder

	with open(args.run_dir+'tile_id_population_{}.pkl'.format(args.run_name), 'wb') as filehandler:
		pickle.dump(tile_id_population, filehandler)

if bank.templates is None:
	print("No templates were added to the bank: the bank is not saved")
	quit()

print("Generated bank with {} templates".format(len(bank.templates)))
print("Saving bank to {}".format(args.run_dir))
bank.save_bank(args.run_dir+'bank_{}.dat'.format(args.run_name))
bank.save_bank(args.run_dir+'bank_{}.xml.gz'.format(args.run_name), args.ifo); title = ''

if args.plot:
	dist = avg_dist(args.mm, bank.D) if bank.D == 2 else None
	plot_tiles_templates(t_obj, bank.templates, args.variable_format, var_handler, dist_ellipse = dist, save_folder = plot_folder, show = args.show)














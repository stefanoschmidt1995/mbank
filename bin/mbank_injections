#!/usr/bin/env python
"""
A script to draw injections at a bank and measure the match between the templates of a bank.
It needs a tiling file so that everything can be sped up
-----
To place the templates:
	mbank_injections --options-you-like
Make sure that the mbank is installed with
	python setup.py sdist
	pip install dist/mbank-0.0.1.tar.gz
To know which options are available:
	mbank_injections --help
"""
#MEMO: Pay attention as N_neigh_templates and N_neigh_tiles are crucial for getting nice results!

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches
import sys
import pickle
import json

from ligo.lw import utils as lw_utils
from ligo.lw import ligolw
from ligo.lw import table as lw_table
from ligo.lw import lsctables

try:
	sys.path.insert(0, '../mbank')
	from mbank import spin_handler, WF_metric, GW_bank, tiling_handler
	from mbank.utils import compute_metric_injections_match, compute_metric_injections_match_bruteforce, compute_injections_match, ray_compute_injections_match, compute_avg_dist, parse_from_file, load_PSD
except:
	from mbank import spin_handler, WF_metric, GW_bank, tiling_handler
	from mbank.utils import compute_metric_injections_match, compute_metric_injections_match_bruteforce, compute_injections_match, compute_avg_dist, parse_from_file, load_PSD

from itertools import combinations, permutations

import argparse
import os

def int_tuple_type(strings):
	strings = strings.replace("(", "").replace(")", "")
	mapped_int = map(int, strings.split(","))
	return tuple(mapped_int)

@lsctables.use_in
class LIGOLWContentHandler(ligolw.LIGOLWContentHandler):
	pass

##### Creating parser
s = spin_handler()
parser = argparse.ArgumentParser(__doc__)
parser.add_argument(
	'--ini-file', type=open, action=parse_from_file, required = False,
	help="Initialization file that stores any option for the parser. An option will be overwritten if the command is given explicitely by command line and differes from default. If the option is left blank, all the arguments will be read from command line.")
parser.add_argument(
	"--injs-per-tile",  default = 10, type = int,
	help="How many injections per each tile shall be done? This is ignored if an injection file is provided")
parser.add_argument(
	"--inj-file", type = str, default = None,
	help="An xml injection file to load the injections from. If not provided, the injections will be performed at random in each tile (injs-per-tile)")
parser.add_argument(
	"--bank-file", required = False, type = str,
	help="Path to the file of a bank")
parser.add_argument(
	"--tiling-file", required = False, type = str,
	help="The input file with a tiling. It must be generated by a tiling_handler object")
parser.add_argument(
	"--N-neigh-templates", type = int, default = 100,
	help="Number of neighbouring templates to be considered for the computation of the match with METRIC approximation")
parser.add_argument(
	"--N-neigh-templates-full", type = int, default = None,
	help="Number of neighbouring templates to be considered for the computation of the match (no approx). If None, it is set to the value of N-neigh-templates")
parser.add_argument(
	"--N-neigh-tiles", type = int, default = 20,
	help="Number of neighbouring tiles in which look for the best match")
parser.add_argument(
	"--N-inj", type = int, default = None,
	help="Number of injections to read from inj-file. If None, all the injections will be read")
parser.add_argument(
	"--full-match", action='store_true', default = False,
	help="Whether to perform the full standard match computation. If False, a metric approximation to the match will be used")
parser.add_argument(
	"--full-match-symphony", action='store_true', default = False,
	help="Whether to perform the full symphony match computation. If False, a metric approximation to the match will be used")
parser.add_argument(
	"--seed", type = int, default = None,
	help="Random seed for extracting the random injections (if it applies)")
parser.add_argument(
	"--use-ray", action='store_true', default = False,
	help="Whether to use ray package to parallelize the match computation")

###########
parser.add_argument(
	"--spin-format", choices= s.valid_formats, required = False,
	help="Choose which spin variables to include in the bank")
parser.add_argument(
	"--psd",  required = False,
	help="The input file for the PSD: it can be either a txt either a ligolw xml file. Only applies if full-match is True")
parser.add_argument(
	"--asd",  default = False, action='store_true',
	help="Whether the input file has an ASD (sqrt of the PSD)")
parser.add_argument(
	"--ifo", default = 'L1', type=str, choices = ['L1', 'H1', 'V1'],
	help="Interferometer name: it can be L1, H1, V1. This is a field for the xml PSD file")
parser.add_argument(
	"--plot", action='store_true',
	help="Whether to make some plots. They will be store in out-dir")
parser.add_argument(
	"--show", action='store_true',
	help="Whether to show the plots.")
parser.add_argument(
	"--out-dir", default = None,
	help="Output directory in which the output will be saved. If default is used, the output will be saved in the same folder of the bank.")
parser.add_argument(
	"--f-min",  default = 10., type=float,
	help="Minium frequency for the scalar product")
parser.add_argument(
	"--f-high",  default = 1024., type=float,
	help="Maximum frequency for the scalar product")
parser.add_argument(
	"--MM", type = float,
	help="Minimum match for the bank - for plotting purposes")
parser.add_argument(
	"--approximant", default = 'IMRPhenomPv2',
	help="LAL approximant for the bank generation")

args, _ = parser.parse_known_args()

##################################################
	######
	#	Interpreting the parser and initializing variables
	######

if args.N_neigh_templates_full is None: args.N_neigh_templates_full = args.N_neigh_templates

if (args.bank_file is None) or (args.tiling_file is None) or (args.spin_format is None):
	raise ValueError("The arguments bank-file, tiling-file and spin_format must be set!")

if args.out_dir is None: args.out_dir = args.bank_file.replace(os.path.basename( args.bank_file), '')
if not args.out_dir.endswith('/'): args.out_dir = args.out_dir+'/'
if not os.path.exists(args.out_dir): os.makedirs(args.out_dir)

plot_folder = None
if args.plot: plot_folder = args.out_dir

	######
	#	Loading PSD, and creating an istance of metric (if it applies)
	######
if args.full_match or args.full_match_symphony: #in this case we need to load the PSD and instantiate the metric
		#load PSD
	f, PSD = load_PSD(args.psd, args.asd, args.ifo)

		#create metric
	metric = WF_metric(PSD = (f, PSD), approx = args.approximant,
			f_min = args.f_min, f_high = args.f_high,
			spin_format = args.spin_format)

	######
	#	Loading the bank and instatianting a spin handler
	#	We also try to load a tile_id_population obj
	######
bank = GW_bank(args.bank_file, spin_format = args.spin_format)
print("Loaded bank {} with {} templates".format(args.bank_file, bank.templates.shape[0]))
s = spin_handler()

t_obj = tiling_handler(args.tiling_file)

	#looking for an option al tile_id_population object saved in the out folder.
	#If there is None, no big deal: it will be created from scratch
tile_id_population_file = os.path.dirname(args.bank_file)
if tile_id_population_file == '': tile_id_population_file = '.'

tile_id_population_file = [ f for f in os.listdir(tile_id_population_file) if f.find('tile_id_population') != -1 ]
if len(tile_id_population_file) == 1:
	with open('{}/{}'.format(os.path.dirname(args.bank_file),tile_id_population_file[0]), 'rb') as filehandler:
		tile_id_population = pickle.load(filehandler)
else:
	tile_id_population = None

	######
	#	Generating injections
	######

if args.inj_file is None:
		#generating tiles injections
	if args.seed is not None: np.random.seed(args.seed)
	projected_injs = [np.random.uniform(t[0].mins, t[0].maxes, (args.injs_per_tile, len(t[0].maxes))) for t in t_obj]
	projected_injs = np.concatenate(projected_injs, axis =0) #(N_tiles * inj_per_tile, D)
	
	#projected_injs = bank.templates; print("######### Bank injections!! ###########") #FIXME: this will become a bank-injs option!! Or something similar
	
	injections_full = np.array(s.get_BBH_components(projected_injs, args.spin_format)).T
	del projected_injs #storing projected_injs is a waste of memory that can scale super badly
else:
	injections = []
	
		#loading injections from file and projecting them on the bank manifold
		#The injection fle can be either xml or json
	if args.inj_file.endswith('xml') or args.inj_file.endswith('xml.gz'):
		xmldoc = lw_utils.load_filename(args.inj_file, verbose = False, contenthandler = LIGOLWContentHandler)
		sim_inspiral_table = lsctables.SimInspiralTable.get_table(xmldoc)

		if args.N_inj is None: args.N_inj = len(sim_inspiral_table)
		if args.N_inj > len(sim_inspiral_table): args.N_inj = len(sim_inspiral_table)

		for i, row in enumerate(sim_inspiral_table):
			if i >= args.N_inj: break
			injections.append([row.mass1, row.mass2, row.spin1x, row.spin1y, row.spin1z, row.spin2x, row.spin2y, row.spin2z, row.inclination, row.coa_phase])
				
	elif args.inj_file.endswith('json'):
		with open(args.inj_file) as f:
			inj_json = json.load(f)
		
		if args.N_inj is None: args.N_inj = len(inj_json['items'])
		if args.N_inj > len(inj_json['items']): args.N_inj = len(inj_json['items'])
		
		for i, row in enumerate(inj_json['items']):
			if i >= args.N_inj: break
			injections.append([row['m1'], row['m2'], row['s_1x'], row['s_1y'], row['s_1z'], row['s_2x'], row['s_2y'], row['s_2z'], row['inclination'], 0.]) #You set phi arbitrarly!! Pay attention
	
		
	else:
		raise ValueError("Format for the input file for the injections must be either xml or json")
	
	print("Loaded {} injections from file: {}".format(args.N_inj, args.inj_file))
	injections_full = np.array(injections) #(N,10)

	######
	#	Computing tiling_injections with metric approximation
	#	Here injections are projected to the bank manifold
	######
injection_stat_dict = compute_metric_injections_match_bruteforce(injections_full, bank,  t_obj, N_neigh_templates = args.N_neigh_templates)

#injection_stat_dict = compute_metric_injections_match(injections_full, bank, t_obj,
#			N_neigh_templates = args.N_neigh_templates, N_neigh_tiles = args.N_neigh_tiles,
#			tile_id_population = tile_id_population)
#out_list = compute_avg_dist(bank, t_obj, metric)

	######
	#	Recomputing the match with the actual match and with the actual injections (non-projected)
	#	(if it's the case)
	######
if args.full_match or args.full_match_symphony:
	templates_full = np.array(s.get_BBH_components(bank.templates, args.spin_format)).T #(N,10)
		#this function should take the stat_dict and for each best_id, it should replace the metric match with the actual match
		#The actual match shall be computed with metric.WF_match
		#The function returns an updated version of injection_stat_dict
	metric.set_spin_format('m1m2_fullspins_iotaphi')

	best_matches_metric = np.array(injection_stat_dict['match'])

	if args.use_ray:
		injection_stat_dict = ray_compute_injections_match(injection_stat_dict, templates_full, metric,
				args.N_neigh_templates_full, symphony_match = args.full_match_symphony)
	else:
		injection_stat_dict = compute_injections_match(injection_stat_dict, templates_full, metric,
				args.N_neigh_templates_full, symphony_match = args.full_match_symphony)
	metric.set_spin_format(args.spin_format)
	
	######
	#	Writing to file
	######
save_name = os.path.basename(args.bank_file).split('.')[0]+'-tile_injections.pkl'

with open(args.out_dir+save_name, 'wb') as filehandler:
	pickle.dump(injection_stat_dict, filehandler)
	
	#to load... just in case
#with open(args.out_dir+save_name, 'rb') as filehandler:
#	injection_stat_dict = pickle.load( filehandler)


	######
	#	Making some plots
	######
if args.plot:
	
		#projecting over the template manifold
	projected_injs = s.get_theta(injections_full, args.spin_format) #(N,D)
	
		#histogram for the overall match
	
	best_matches = injection_stat_dict['match']
	best_matches[best_matches<=0] = 0.01
	
	print("Matches percentiles [50, 5, 1]: ", np.percentile(best_matches, [50, 5,1]))
	
		###
		# Histogram
		###
	plt.figure()
	plt.title("Injection recovery for bank {}".format(os.path.basename(args.bank_file)))
	N_bins = 30
	logbins = np.logspace(np.log10(np.percentile(best_matches, [.5])[0]),np.log10(max(best_matches)), N_bins)
	plt.hist(best_matches, bins = logbins, density = True)
	if args.full_match: plt.hist(best_matches_metric, bins = logbins, histtype='step', density = True)
	
	if isinstance(args.MM, (float, int)): plt.axvline(x = args.MM, c = 'r') #DEBUG
	plt.xscale('log')
	#plt.show()
	plt.savefig(args.out_dir+'FF_hist.png')

	ids_to_plot = np.where(best_matches<np.percentile(best_matches, 50))[0]

		###
		# Colored plots
		###
	fig, axes = plt.subplots(projected_injs.shape[1]-1, projected_injs.shape[1]-1, figsize = (20,20))
	plt.suptitle("Bad injections for {}".format(os.path.basename(args.bank_file)))
	if projected_injs.shape[1]-1 == 1:
		axes = np.array([[axes]])
	for i,j in permutations(range(projected_injs.shape[1]-1), 2):
		if i<j:	axes[i,j].remove()
	
	for ax_ in combinations(range(projected_injs.shape[1]), 2):
		currentAxis = axes[ax_[1]-1, ax_[0]]
		ax_ = list(ax_)
		
		#fig = plt.figure()
		currentAxis.scatter(*bank.templates[:,ax_].T, s = 2, marker = 'x', c= 'r', alpha = 0.5)
		cbar_vals = currentAxis.scatter(projected_injs[ids_to_plot,ax_[0]], projected_injs[ids_to_plot,ax_[1]],
				s = 20, marker = 'o', c= best_matches[ids_to_plot])
		if ax_[0] == 0:
			currentAxis.set_ylabel(s.labels(args.spin_format, latex = True)[ax_[1]])
		else:
			currentAxis.set_yticks([])
		if ax_[1] == projected_injs.shape[1]-1:
			currentAxis.set_xlabel(s.labels(args.spin_format, latex = True)[ax_[0]])
		else:
			currentAxis.set_xticks([])
		
		for t in t_obj:
			d = t[0].maxes- t[0].mins
			currentAxis.add_patch(matplotlib.patches.Rectangle(t[0].mins[ax_], d[ax_[0]], d[ax_[1]], fill = None, alpha =1))
	
	cbar_ax = fig.add_axes([0.95, 0.15, 0.015, 0.7])
	fig.colorbar(cbar_vals, cax=cbar_ax)
	plt.subplots_adjust(wspace=0, hspace=0, bottom = 0.05, right = 0.92, left = 0.05, top = 0.97)
	plt.savefig(args.out_dir+'injections_scatter.png')
	
	if args.show: plt.show()





















	
	
	

#!/usr/bin/env python
"""
A script to run mbank for generating a bank
-----
To generate a bank:
	mbank_run --options-you-like
Make sure that the mbank is installed with
	python setup.py sdist
	pip install dist/mbank-0.0.1.tar.gz
To know which options are available:
	mbank_run --help
"""
import numpy as np
import matplotlib.pyplot as plt
import sys
import pickle
import lal.series
from ligo.lw.utils import load_filename

from mbank import variable_handler, cbc_metric, cbc_bank
from mbank.utils import parse_from_file, load_PSD

import argparse
import os

def int_tuple_type(strings):
	strings = strings.replace("(", "").replace(")", "")
	mapped_int = map(int, strings.split(","))
	return tuple(mapped_int)


##### Creating parser
var_handler = variable_handler()
parser = argparse.ArgumentParser(__doc__)
parser.add_argument(
	'--ini-file', type=open, action=parse_from_file, required = False,
	help="Initialization file that stores any option for the parser. An option will be overwritten if the command is given explicitely by command line and differes from default. If the option is left blank, all the arguments will be read from command line.")
parser.add_argument(
	"--variable-format", choices= var_handler.valid_formats, required = False,
	help="Choose which variables to include in the bank")
parser.add_argument(
	"--MM", required = False, type = float,
	help="Minimum match for the bank (a.k.a. average distance between templates)")
parser.add_argument(
	"--psd",  required = False,
	help="The input file for the PSD: it can be either a txt either a ligolw xml file")
parser.add_argument(
	"--asd",  default = False, action='store_true',
	help="Whether the input file has an ASD (sqrt of the PSD)")
parser.add_argument(
	"--ifo", default = 'L1', type=str, choices = ['L1', 'H1', 'V1'],
	help="Interferometer name: it can be L1, H1, V1. This is a field for the xml files for the PSD and the bank")
parser.add_argument(
	"--plot", action='store_true',
	help="Whether to make some plots. They will be store in run-dir")
parser.add_argument(
	"--show", action='store_true',
	help="Whether to show the plots.")
parser.add_argument(
	"--run-dir", default = './out_$(run_name)',
	help="Output directory in which the bank will be saved. If default is used, the bank name will be appended.")
parser.add_argument(
	"--run-name", default = 'cbc_mbank',
	help="Name for the bank output file")
parser.add_argument(
	"--grid-size", default = None, type=int_tuple_type,
	help="Number of grid points for each dimension. The number of grid must match the number extra dimensions. If None, the grid size will be a set of ones")
parser.add_argument(
	"--f-min",  default = 10., type=float,
	help="Minium frequency for the scalar product")
parser.add_argument(
	"--f-max",  default = 1024., type=float,
	help="Maximum frequency for the scalar product")
parser.add_argument(
	"--approximant", default = 'IMRPhenomPv2',
	help="LAL approximant for the bank generation")
parser.add_argument(
	"--placing-method", default = 'p_disc', type = str, choices = ['p_disc', 'uniform', 'geometric', 'iterative', 'stochastic', 'pure_stochastic'],
	help="Which placing method to use for each tile")
parser.add_argument(
	"--template-in-tile", default = 200, type = int,
	help="How many templates should lie in each tile?")
parser.add_argument(
	"--use-ray", action='store_true', default = False,
	help="Whether to use ray package to parallelize the metric computation")
	
	#ranges for physical parameters
parser.add_argument(
	"--m-range", default = [10., 100], type=float, nargs = 2,
	help="Range values for the masses (in solar masses)")
parser.add_argument(
	"--mtot-range", default = [10., 100], type=float, nargs = 2,
	help="Range values for the total masses (in solar masses).")
parser.add_argument(
	"--q-range", default = [1., 10.], type=float, nargs = 2,
	help="Range values for the mass ratio.")
parser.add_argument(
	"--mc-range", default = [10., 100], type=float, nargs = 2,
	help="Range values for the total masses (in solar masses).")
parser.add_argument(
	"--eta-range", default = [.18, .25], type=float, nargs = 2,
	help="Range values for the mass ratio.")
parser.add_argument(
	"--s1-range", default = [-0.8,0.8], type=float, nargs = 2,
	help="Range values for magnitude of spin 1 (if applicable)")
parser.add_argument(
	"--s2-range", default = [-0.8,0.8], type=float, nargs = 2,
	help="Range values for magnitude of spin 1 (if applicable)")
parser.add_argument(
	"--theta-range", default = [0., np.pi], type=float, nargs = 2,
	help="Range values for theta angles of spins (if applicable)")
parser.add_argument(
	"--phi-range", default = [-np.pi, np.pi], type=float, nargs = 2,
	help="Range values for phi angles of spins (if applicable)")
parser.add_argument(
	"--e-range", default = [0., 0.5], type=float, nargs = 2,
	help="Range values for the eccentricity (if applicable)")
parser.add_argument(
	"--meanano-range", default = [0., 1], type=float, nargs = 2,
	help="Range values for the mean anomaly (if applicable). TODO: find a nice default...")
parser.add_argument(
	"--iota-range", default = [0., np.pi], type=float, nargs = 2,
	help="Range values for iota (if applicable)")
parser.add_argument(
	"--ref-phase-range", default = [-np.pi, np.pi], type=float, nargs = 2,
	help="Range values for reference phase (if applicable)")


args, _ = parser.parse_known_args()

####################################################################################################
	######
	#	Interpreting the parser and initializing variables
	######

if (args.psd is None) or (args.MM is None) or (args.variable_format is None):
	raise ValueError("The arguments MM, PSD and variable_format must be set!")

if args.run_dir == './out_$(run_name)':	args.run_dir = './out_{}/'.format(args.run_name)
if not args.run_dir.endswith('/'): args.run_dir = args.run_dir+'/'
if not os.path.exists(args.run_dir): os.makedirs(args.run_dir)

if args.grid_size is None: args.grid_size = tuple([1 for i in range(s.D(args.variable_format))])

m_min, m_max = args.m_range
mtot_min, mtot_max = args.mtot_range
q_min, q_max = args.q_range
mc_min, mc_max = args.mc_range
eta_min, eta_max = args.eta_range
s1_min, s1_max = args.s1_range
s2_min, s2_max = args.s2_range
theta_min, theta_max = args.theta_range
e_min, e_max = args.e_range
meanano_min, meanano_max = args.meanano_range
phi_min, phi_max = args.phi_range
iota_min, iota_max = args.iota_range
ref_phase_min, ref_phase_max = args.ref_phase_range

plot_folder = None
if args.plot: plot_folder = args.run_dir

format_info = var_handler.format_info[args.variable_format]

	######
	#	Setting boundaries: shape (2,D)
	######
	#setting mass boundaries
if format_info['mass_format'] == 'm1m2':
	var1_min, var1_max = m_min, m_max
	var2_min, var2_max = m_min, m_max
elif format_info['mass_format'] == 'Mq':
	var1_min, var1_max = mtot_min, mtot_max
	var2_min, var2_max = q_min, q_max
elif format_info['mass_format'] == 'mceta':
	var1_min, var1_max = mc_min, mc_max
	var2_min, var2_max = eta_min, eta_max

	#setting spin boundaries
if format_info['spin_format'] == 'nonspinning':
	boundaries = np.array([[var1_min, var2_min],[var1_max, var2_max]])
elif format_info['spin_format'] == 's1z_s2z':
	boundaries = np.array([[var1_min, var2_min, s1_min, s2_min],[var1_max, var2_max, s1_max, s2_max]])
elif format_info['spin_format'] == 's1xz':
	boundaries = np.array([[var1_min, var2_min, s1_min, theta_min],[var1_max, var2_max, s1_max, theta_max]])
elif format_info['spin_format'] == 's1xz_s2z':
	boundaries = np.array([[var1_min, var2_min, s1_min, theta_min, s2_min],[var1_max, var2_max, s1_max, theta_max, s2_max]])
elif format_info['spin_format'] == 's1xyz_s2z':
	boundaries = np.array([[var1_min, var2_min, s1_min, theta_min, phi_min, s2_min],[var1_max, var2_max, s1_max, theta_max, phi_max, s2_max]])
elif format_info['spin_format'] == 'fullspins':
	boundaries = np.array([[var1_min, var2_min, s1_min, theta_min, phi_min, s2_min, theta_min, phi_min,],[var1_max, var2_max, s1_max, theta_max, phi_max, s2_max, theta_max, phi_max]])
else:
	raise RuntimeError("Boundaries current not implemented for the required format of spins {}: apologies :(".format(format_info['spin_format']))

if format_info['e']:
	boundaries = np.concatenate([boundaries, [[e_min], [e_max]]], axis =1)
if format_info['meanano']:
	boundaries = np.concatenate([boundaries, [[meanano_min], [meanano_max]]], axis =1)
if format_info['iota']:
	boundaries = np.concatenate([boundaries, [[iota_min], [iota_max]]], axis =1)
if format_info['phi']:
	boundaries = np.concatenate([boundaries, [[ref_phase_min], [ref_phase_max]]], axis =1)

	######
	#	Loading PSD and initializing metric
	######
m = cbc_metric(args.variable_format,
			PSD = load_PSD(args.psd, args.asd, args.ifo),
			approx = args.approximant,
			f_min = args.f_min, f_max = args.f_max)

print("## Running: ", args.run_name)

	######
	#	Running and saving the output
	######
bank = cbc_bank(args.variable_format)

if format_info['mass_format'] == 'm1m2':
	raise NotImplementedError("Currently no template placement is implemented for the mass format m1m2.")

if format_info['mass_format'] == 'Mq' or format_info['mass_format'] == 'mceta':
	
	t_obj, tile_id_population = bank.generate_bank(m, avg_match = args.MM, boundaries = boundaries, N_temp = args.template_in_tile,
		grid_list = args.grid_size, placing_method = args.placing_method, plot_folder = plot_folder, use_ray = args.use_ray, show = args.show)
	
	t_obj.save(args.run_dir+'tiling_{}.npy'.format(args.run_name)) #storing the tiling in the out_folder

	with open(args.run_dir+'tile_id_population_{}.pkl'.format(args.run_name), 'wb') as filehandler:
		pickle.dump(tile_id_population, filehandler)

if bank.templates is None:
	print("No templates were added to the bank: the bank is not saved")
	quit()

print("Generated bank with {} templates".format(len(bank.templates)))
print("Saving bank to {}".format(args.run_dir))
bank.save_bank(args.run_dir+'bank_{}.dat'.format(args.run_name))
bank.save_bank(args.run_dir+'bank_{}.xml.gz'.format(args.run_name), args.ifo); title = ''















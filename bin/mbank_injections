#!/usr/bin/env python
"""
A script to draw injections at a bank and measure the match between the templates of a bank.
It needs a tiling file so that everything can be sped up
Usage
-----
To place the templates:
	mbank_injections --options-you-like
Make sure that the mbank is installed with
	python setup.py sdist
	pip install dist/mbank-0.0.1.tar.gz
To know which options are available:
	mbank_injections --help
"""
#MEMO: Pay attention as N_neigh_templates and N_neigh_tiles are crucial for getting nice results!

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches
import sys
import pickle

from ligo.lw import utils as lw_utils
from ligo.lw import ligolw
from ligo.lw import table as lw_table
from ligo.lw import lsctables

from mbank import *
from mbank.utils import compute_metric_injections_match, compute_metric_injections_match_bruteforce, compute_injections_match, compute_avg_dist

from itertools import combinations, permutations

import argparse
import os

def int_tuple_type(strings):
	strings = strings.replace("(", "").replace(")", "")
	mapped_int = map(int, strings.split(","))
	return tuple(mapped_int)

@lsctables.use_in
class LIGOLWContentHandler(ligolw.LIGOLWContentHandler):
	pass

##### Creating parser
s = spin_handler()
parser = argparse.ArgumentParser(__doc__)
parser.add_argument(
	"--injs-per-tile",  default = 10, type = int,
	help="How many injections per each tile shall be done? This is ignored if an injection file is provided")
parser.add_argument(
	"--inj-file", type = str, default = None,
	help="An xml injection file to load the injections from. If not provided, the injections will be performed at random in each tile (injs-per-tile)")
parser.add_argument(
	"--bank-file", required = True, type = str,
	help="Path to the file of a bank")
parser.add_argument(
	"--tiling-file", required = True, type = str,
	help="The input file with a tiling. It must be generated by a tiling_handler object")
parser.add_argument(
	"--N-neigh-templates", type = int, default = 100,
	help="Number of neighbouring templates to be considered for the match computation")
parser.add_argument(
	"--N-neigh-tiles", type = int, default = 20,
	help="Number of neighbouring tiles in which look for the best match")
parser.add_argument(
	"--full-match", action='store_true', default = False,
	help="Whether to perform the full match computation. If False, a metric approximation to the match will be used")
###########
parser.add_argument(
	"--spin-format", choices= s.valid_formats, required = True,
	help="Choose which spin variables to include in the bank")
parser.add_argument(
	"--psd",  required = True,
	help="The input file for the PSD")
parser.add_argument(
	"--asd",  default = False, action='store_true',
	help="Whether the input file has an ASD (sqrt of the PSD)")
parser.add_argument(
	"--plot", action='store_true',
	help="Whether to make some plots. They will be store in out-dir")
parser.add_argument(
	"--show", action='store_true',
	help="Whether to show the plots.")
parser.add_argument(
	"--out-dir", default = None,
	help="Output directory in which the output will be saved. If default is used, the output will be saved in the same folder of the bank.")
parser.add_argument(
	"--f-min",  default = 10., type=float,
	help="Minium frequency for the scalar product")
parser.add_argument(
	"--f-high",  default = 1024., type=float,
	help="Maximum frequency for the scalar product")
parser.add_argument(
	"--approximant", default = 'IMRPhenomPv2',
	help="LAL approximant for the bank generation")

args, _ = parser.parse_known_args()

##################################################
	######
	#	Interpreting the parser and initializing variables
	######

if args.out_dir is None: args.out_dir = args.bank_file.replace(os.path.basename( args.bank_file), '')
if not args.out_dir.endswith('/'): args.out_dir = args.out_dir+'/'
if not os.path.exists(args.out_dir): os.makedirs(args.out_dir)

plot_folder = None
if args.plot: plot_folder = args.out_dir

	######
	#	Generating metric, bank and tiling
	######

f, PSD = np.loadtxt(args.psd)[:,:2].T
if args.asd: PSD = np.square(PSD)

metric = WF_metric(PSD = (f, PSD), approx = args.approximant,
		f_min = args.f_min, f_high = args.f_high,
		spin_format = args.spin_format)

bank = GW_bank(args.bank_file, spin_format = args.spin_format)
s = spin_handler()

t_obj = tiling_handler(args.tiling_file)

	#looking for an option al tile_id_population object saved in the out folder.
	#If there is None, no big deal: it will be created from scratch
tile_id_population_file = os.path.dirname(args.bank_file)
tile_id_population_file = [ f for f in os.listdir(tile_id_population_file) if f.find('tile_id_population') != -1 ]
if len(tile_id_population_file) == 1:
	with open('{}/{}'.format(os.path.dirname(args.bank_file),tile_id_population_file[0]), 'rb') as filehandler:
		tile_id_population = pickle.load(filehandler)
else:
	tile_id_population = None

	######
	#	Generating injections
	######

if args.inj_file is None:
		#generating tiles injections
	projected_injs = [np.random.uniform(t[0].mins, t[0].maxes, (args.injs_per_tile, len(t[0].maxes))) for t in t_obj]
	projected_injs = np.concatenate(projected_injs, axis =0) #(N_tiles * inj_per_tile, D)
	
		#cropping injections
	#projected_injs = projected_injs[np.where( np.prod(projected_injs >= [3,1., 0.,0., -np.pi, -0.95], axis =1) & np.prod(projected_injs <= [300, 4., 0.95, np.pi, np.pi, 0.99], axis =1) )]
	#projected_injs = projected_injs[np.where( np.prod(projected_injs > [3,1., 0.,-100, -100, -0.9], axis =1) & np.prod(projected_injs < [300, 4., 0.9, 100, 100, 0.9], axis =1) )]
	
	injections_full = np.array(s.get_BBH_components(projected_injs, args.spin_format)).T
	del projected_injs #storing projected_injs is a waste of memory that can scale super badly
else:
		#loading injections from file and projecting them on the bank manifold
	xmldoc = lw_utils.load_filename(args.inj_file, verbose = True, contenthandler = LIGOLWContentHandler)
	print(args.inj_file)
	sim_inspiral_table = lsctables.SimInspiralTable.get_table(xmldoc)
		
	injections = []
			
	for row in sim_inspiral_table:
		injections.append([row.mass1, row.mass2, row.spin1x, row.spin1y, row.spin1z, row.spin2x, row.spin2y, row.spin2z, row.inclination, row.coa_phase])
			
	injections_full = np.array(injections) #(N,10)

	######inj_dict['match'][ids_low]
	#	Computing tiling_injections with metric approximation
	#	Here injections are projected to the bank manifold
	######
injection_stat_dict = compute_metric_injections_match_bruteforce(injections_full, bank,  t_obj, N_neigh_templates = args.N_neigh_templates)
#injection_stat_dict = compute_metric_injections_match(injections_full, bank, t_obj, metric,
#			N_neigh_templates = args.N_neigh_templates, N_neigh_tiles = args.N_neigh_tiles,
#			tile_id_population = tile_id_population)
#out_list = compute_avg_dist(bank, t_obj, metric)

	######
	#	Recomputing the match with the actual match and with the actual injections (non-projected)
	#	(if it's the case)
	######
if args.full_match:
	templates_full = np.array(s.get_BBH_components(bank.templates, args.spin_format)).T #(N,10)
		#this function should take the stat_dict and for each best_id, it should replace the metric match with the actual match
		#The actual match shall be computed with metric.WF_match
		#The function returns an updated version of injection_stat_dict
	metric.set_spin_format('m1m2_fullspins_iotaphi')

	best_matches_metric = np.array(injection_stat_dict['match'])

	injection_stat_dict = compute_injections_match(injection_stat_dict, templates_full, metric)
	metric.set_spin_format(args.spin_format)
	
	######
	#	Writing to file
	######
save_name = os.path.basename(args.bank_file).split('.')[0]+'-tile_injections.pkl'

with open(args.out_dir+save_name, 'wb') as filehandler:
	pickle.dump(injection_stat_dict, filehandler)
	
	#to load... just in case
#with open(args.out_dir+save_name, 'rb') as filehandler:
#	injection_stat_dict = pickle.load( filehandler)


	######
	#	Making some plots
	######
if args.plot:
	
		#projecting over the template manifold
	projected_injs = s.get_theta(injections_full, args.spin_format) #(N,D)
	
		#histogram for the overall match
	
	best_matches = injection_stat_dict['match']
	best_matches[best_matches<=0] = 0.01
	
	print("Matches percentiles [50, 5, 1]: ", np.percentile(best_matches, [50, 5,1]))
	
		###
		# Histogram
		###
	plt.figure()
	N_bins = 20
	logbins = np.logspace(np.log10(np.percentile(best_matches, [.5])[0]),np.log10(max(best_matches)), N_bins)
	plt.hist(best_matches, bins = logbins, density = True)
	if args.full_match: plt.hist(best_matches_metric, bins = logbins, histtype='step', density = True)
	
	plt.axvline(x = 0.97, c = 'r') #DEBUG
	plt.xscale('log')
	#plt.show()
	plt.savefig(args.out_dir+'FF_hist.png')

	ids_to_plot = np.where(best_matches<np.percentile(best_matches, 5))[0]

		###
		# Colored plots
		###
	fig, axes = plt.subplots(projected_injs.shape[1]-1, projected_injs.shape[1]-1, figsize = (20,20))
	if projected_injs.shape[1]-1 == 1:
		axes = np.array([[axes]])
	for i,j in permutations(range(projected_injs.shape[1]-1), 2):
		if i<j:	axes[i,j].remove()
	
	for ax_ in combinations(range(projected_injs.shape[1]), 2):
		currentAxis = axes[ax_[1]-1, ax_[0]]
		ax_ = list(ax_)
		
		#fig = plt.figure()
		currentAxis.scatter(*bank.templates[:,ax_].T, s = 5, marker = 'x', c= 'r', alpha = 0.5)
		cbar_vals = currentAxis.scatter(projected_injs[ids_to_plot,ax_[0]], projected_injs[ids_to_plot,ax_[1]],
				s = 20, marker = 'o', c= best_matches[ids_to_plot])
		if ax_[0] == 0:
			currentAxis.set_ylabel(s.labels(args.spin_format, latex = True)[ax_[1]])
		else:
			currentAxis.set_yticks([])
		if ax_[1] == projected_injs.shape[1]-1:
			currentAxis.set_xlabel(s.labels(args.spin_format, latex = True)[ax_[0]])
		else:
			currentAxis.set_xticks([])
		
		for t in t_obj:
			d = t[0].maxes- t[0].mins
			currentAxis.add_patch(matplotlib.patches.Rectangle(t[0].mins[ax_], d[ax_[0]], d[ax_[1]], fill = None, alpha =1))
	
	cbar_ax = fig.add_axes([0.95, 0.15, 0.015, 0.7])
	fig.colorbar(cbar_vals, cax=cbar_ax)
	plt.subplots_adjust(wspace=0, hspace=0, bottom = 0.05, right = 0.92, left = 0.05, top = 0.97)
	plt.savefig(args.out_dir+'injections_scatter.png')
	
	if args.show: plt.show()





















	
	
	

#!/usr/bin/env python
"""
A script to draw injections at a bank and measure the match between the templates of a bank.
It needs a tiling file so that everything can be sped up
Usage
-----
To place the templates:
	mbank_injections --options-you-like
Make sure that the mbank is installed with
	python setup.py sdist
	pip install dist/mbank-0.0.1.tar.gz
To know which options are available:
	mbank_injections --help
"""
#MEMO: Pay attention as N_neigh_templates and N_neigh_tiles are crucial for getting nice results!

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches
import sys
import pickle 

from ligo.lw import utils as lw_utils
from ligo.lw import ligolw
from ligo.lw import table as lw_table
from ligo.lw import lsctables

from mbank import *
from mbank.utils import compute_metric_injections_match, compute_avg_dist

import argparse
import os

def int_tuple_type(strings):
	strings = strings.replace("(", "").replace(")", "")
	mapped_int = map(int, strings.split(","))
	return tuple(mapped_int)

##### Creating parser
s = spin_handler()
parser = argparse.ArgumentParser(__doc__)
parser.add_argument(
	"--injs-per-tile",  default = 10, type = int,
	help="How many injections per each tile shall be done? This is ignored if an injection file is provided")
parser.add_argument(
	"--inj-file", type = str, default = None,
	help="An xml injection file to load the injections from. If not provided, the injections will be performed at random in each tile (injs-per-tile)")
parser.add_argument(
	"--bank-file", required = True, type = str,
	help="Path to the file of a bank")
parser.add_argument(
	"--tiling-file", required = True, type = str,
	help="The input file with a tiling. It must be generated by a tiling_handler object")
parser.add_argument(
	"--N-neigh-templates", type = int, default = 100,
	help="Number of neighbouring templates to be considered for the match computation")
parser.add_argument(
	"--N-neigh-tiles", type = int, default = 20,
	help="Number of neighbouring tiles in which look for the best match")
parser.add_argument(
	"--full-match", action='store_true', default = False,
	help="Whether to perform the full match computation. If False, a metric approximation to the match will be used")
###########
parser.add_argument(
	"--spin-format", choices= s.valid_formats, required = True,
	help="Choose which spin variables to include in the bank")
parser.add_argument(
	"--psd",  required = True,
	help="The input file for the PSD")
parser.add_argument(
	"--asd",  default = False, action='store_true',
	help="Whether the input file has an ASD (sqrt of the PSD)")
parser.add_argument(
	"--plot", action='store_true',
	help="Whether to make some plots. They will be store in out-dir")
parser.add_argument(
	"--out-dir", default = None,
	help="Output directory in which the output will be saved. If default is used, the output will be saved in the same folder of the bank.")
parser.add_argument(
	"--f-min",  default = 10., type=float,
	help="Minium frequency for the scalar product")
parser.add_argument(
	"--f-high",  default = 1024., type=float,
	help="Maximum frequency for the scalar product")
parser.add_argument(
	"--approximant", default = 'IMRPhenomPv2',
	help="LAL approximant for the bank generation")

args, _ = parser.parse_known_args()

##################################################
	######
	#	Interpreting the parser and initializing variables
	######

if args.out_dir is None: args.out_dir = args.bank_file.replace(os.path.basename( args.bank_file), '')
if not args.out_dir.endswith('/'): args.out_dir = args.out_dir+'/'
if not os.path.exists(args.out_dir): os.makedirs(args.out_dir)

plot_folder = None
if args.plot: plot_folder = args.out_dir

	######
	#	Generating metric, bank and tiling
	######

f, PSD = np.loadtxt(args.psd)[:,:2].T
if args.asd: PSD = np.square(PSD)

metric = WF_metric((f, PSD), approx = args.approximant,
		f_min = args.f_min, f_high = args.f_high,
		spin_format = args.spin_format)

bank = GW_bank(args.bank_file, spin_format = args.spin_format)
s = spin_handler()

t_obj = tiling_handler(args.tiling_file)

	######
	#	Generating injections
	######
	
if args.inj_file is None:
		#generating tiles injections
	projected_injs = [np.random.uniform(t[0].mins, t[0].maxes, (args.injs_per_tile, len(t[0].maxes))) for t in t_obj]
	projected_injs = np.concatenate(projected_injs, axis =0) #(N_tiles * inj_per_tile, D)
	injections = projected_injs
else:
		#loading injections from file and projecting them on the bank manifold
	xmldoc = lw_utils.load_filename(args.inj_file, verbose = True, contenthandler = LIGOLWContentHandler)
	sim_inspiral_table = lsctables.SimInspiralTable.get_table(xmldoc)
		
	injections = []
			
	for row in sim_inspiral_table:
		injections.append([row.mass1, row.mass2, row.spin1x, row.spin1y, row.spin1z, row.spin2x, row.spin2y, row.spin2z, row.inclination, row.coa_phase])
			
	injections = np.array(injections) #(N,1)
	projected_injs = s.get_theta(injections, args.spin_format) #(N,D)
	raise NotImplementedError("Please, debug this trash")	

	######
	#	Computing tiling_injections with metric approximation
	#	Here injections are projected to the bank manifold
	######
injection_stat_dict = compute_metric_injections_match(projected_injs, bank, t_obj, metric,
			N_neigh_templates = args.N_neigh_templates, N_neigh_tiles = args.N_neigh_tiles)
#out_list = compute_avg_dist(bank, t_obj, metric)


	######
	#	Recomputing the match with the actual match and with the actual injections (non-projected)
	#	(if it's the case
	######
if args.full_match:
	templates_full = s.get_BBH_components(bank.templates, args.spin_format)
		#this function should take the stat_dict and for each best_id, it should replace the metric match with the actual match
		#The actual match shall be computed with metric.WF_match
		#The function returns an updated version of injection_stat_dict
	injection_stat_dict = compute_injections_match(injection_stat_dict, injections, templates, metric)
	raise NotImplementedError("Do proper injections")

	######
	#	Writing to file
	######
save_name = os.path.splitext(os.path.basename( args.bank_file))[0]+'-tile_injections.pkl'
#filehandler = open(args.out_dir+save_name, 'rb')
#injection_stat_dict = pickle.load( filehandler)

filehandler = open(args.out_dir+save_name, 'wb')
pickle.dump(injection_stat_dict, filehandler)
filehandler.close()

	######
	#	Making some plots
	######
if args.plot:
	
	#histogram for the overall match
	
	best_matches = injection_stat_dict['match']
	best_matches[best_matches<=0] = 0.01
	
	print("Matches percentiles [50, 5, 1]: ", np.percentile(best_matches, [50, 5,1]))
	
	plt.figure()
	N_bins = 20
	logbins = np.logspace(np.log10(np.percentile(best_matches, [.5])[0]),np.log10(max(best_matches)), N_bins)
	plt.hist(best_matches, bins = logbins)
	plt.xscale('log')
	#plt.show()

	fig = plt.figure()
	plt.scatter(*bank.templates[:,[0,1]].T, s = 10, marker = 'x', c= 'r')
	plt.scatter(*projected_injs[:,[0,1]].T, s = 50, marker = 'o', c= best_matches)
	plt.colorbar()
	
	currentAxis = plt.gca()
	for t in t_obj:
		d = t[0].maxes- t[0].mins
		currentAxis.add_patch(matplotlib.patches.Rectangle(t[0].mins, d[0], d[1], fill = None, alpha =1))
	
	plt.show()

	raise NotImplementedError("Please make some nice plots here")




















	
	
	

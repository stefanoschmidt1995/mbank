#!/usr/bin/env python
"""
A script to draw injections at a bank and measure the match between the templates of a bank.
It needs a tiling file so that everything can be sped up
-----
To place the templates:
	mbank_injections --options-you-like
Make sure that the mbank is installed with
	python setup.py sdist
	pip install dist/mbank-0.0.1.tar.gz
To know which options are available:
	mbank_injections --help
"""
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches
import sys
import pickle
import json

from ligo.lw import utils as lw_utils
from ligo.lw import ligolw
from ligo.lw import table as lw_table
from ligo.lw import lsctables

from mbank import variable_handler, cbc_metric, cbc_bank, tiling_handler
from mbank.utils import ray_compute_injections_match, compute_metric_injections_match, compute_metric_injections_match_bruteforce, compute_injections_match, compute_avg_dist, parse_from_file, load_PSD

from itertools import combinations, permutations

import argparse
import os

def int_tuple_type(strings):
	strings = strings.replace("(", "").replace(")", "")
	mapped_int = map(int, strings.split(","))
	return tuple(mapped_int)

@lsctables.use_in
class LIGOLWContentHandler(ligolw.LIGOLWContentHandler):
	pass

##### Creating parser
var_handler = variable_handler()
parser = argparse.ArgumentParser(__doc__)
parser.add_argument(
	'--ini-file', type=open, action=parse_from_file, required = False,
	help="Initialization file that stores any option for the parser. An option will be overwritten if the command is given explicitely by command line and differes from default. If the option is left blank, all the arguments will be read from command line.")
parser.add_argument(
	"--injs-per-tile",  default = 10, type = int,
	help="How many injections per each tile shall be done? This is ignored if an injection file is provided")
parser.add_argument(
	"--inj-file", type = str, default = None,
	help="An xml injection file to load the injections from. If not provided, the injections will be performed at random in each tile (injs-per-tile). If no path to the file is provided, it is understood it is located in run-dir.")
parser.add_argument(
	"--bank-file", required = False, type = str,
	help="Path to the file of a bank. If no path to the file is provided, it is understood it is located in run-dir.")
parser.add_argument(
	"--tiling-file", required = False, type = str,
	help="The input file with a tiling. It must be generated by a tiling_handler object. If no path to the file is provided, it is understood it is located in run-dir.")
parser.add_argument(
	"--N-neigh-templates", type = int, default = 100,
	help="Number of neighbouring templates to be considered for the computation of the match with METRIC approximation")
parser.add_argument(
	"--N-neigh-templates-full", type = int, default = None,
	help="Number of neighbouring templates to be considered for the computation of the match (no approx). If None, it is set to the value of N-neigh-templates")
parser.add_argument(
	"--N-neigh-tiles", type = int, default = 20,
	help="Number of neighbouring tiles in which look for the best match. #### DEPRECATED")
parser.add_argument(
	"--N-inj", type = int, default = None,
	help="Number of injections to read from inj-file. If None, all the injections will be read")
parser.add_argument(
	"--full-match", action='store_true', default = False,
	help="Whether to perform the full standard match computation. If False, a metric approximation to the match will be used")
parser.add_argument(
	"--full-match-symphony", action='store_true', default = False,
	help="Whether to perform the full symphony match computation. If False, a metric approximation to the match will be used")
parser.add_argument(
	"--seed", type = int, default = None,
	help="Random seed for extracting the random injections (if it applies)")
parser.add_argument(
	"--use-ray", action='store_true', default = False,
	help="Whether to use ray package to parallelize the match computation")
parser.add_argument(
	"--cache", action='store_true', default = False,
	help="Whether to cache the computation of the (full) match. It may fill the memory.")

###########
parser.add_argument(
	"--variable-format", choices= var_handler.valid_formats, required = False,
	help="Choose which variables to include in the bank")
parser.add_argument(
	"--psd",  required = False,
	help="The input file for the PSD: it can be either a txt either a ligolw xml file. Only applies if full-match is True")
parser.add_argument(
	"--asd",  default = False, action='store_true',
	help="Whether the input file has an ASD (sqrt of the PSD)")
parser.add_argument(
	"--ifo", default = 'L1', type=str, choices = ['L1', 'H1', 'V1'],
	help="Interferometer name: it can be L1, H1, V1. This is a field for the xml PSD file")
parser.add_argument(
	"--plot", action='store_true',
	help="Whether to make some plots. They will be store in run-dir")
parser.add_argument(
	"--show", action='store_true',
	help="Whether to show the plots. (It authomatically sets the --plot option)")
parser.add_argument(
	"--run-dir", default = None,
	help="Output directory in which the output will be saved. If None, it will be the same folder of --bank-file. Unless explicitly stated, every input file will be understood to be in this run-dir")
parser.add_argument(
	"--f-min",  default = 10., type=float,
	help="Minium frequency for the scalar product")
parser.add_argument(
	"--f-max",  default = 1024., type=float,
	help="Maximum frequency for the scalar product")
parser.add_argument(
	"--MM", type = float,
	help="Minimum match for the bank - for plotting purposes")
parser.add_argument(
	"--approximant", default = 'IMRPhenomPv2',
	help="LAL approximant for the bank generation")

args, _ = parser.parse_known_args()

##################################################
	######
	#	Interpreting the parser and initializing variables
	######

if args.N_neigh_templates_full is None: args.N_neigh_templates_full = args.N_neigh_templates

if (args.bank_file is None) or (args.tiling_file is None) or (args.variable_format is None):
	raise ValueError("The arguments bank-file, tiling-file and variable_format must be set!")

if args.run_dir is None: args.run_dir = args.bank_file.replace(os.path.basename(args.bank_file), '')
if args.run_dir =='': args.run_dir = './'
if not args.run_dir.endswith('/'): args.run_dir = args.run_dir+'/'
if not os.path.exists(args.run_dir): os.makedirs(args.run_dir)

	#setting default locations for injection file, tiling file and bank file
if args.inj_file is not None:
	if args.inj_file.find('/') <0: args.inj_file = args.run_dir+args.inj_file
if args.tiling_file.find('/') <0: args.tiling_file = args.run_dir+args.tiling_file
if args.bank_file.find('/') <0: args.bank_file = args.run_dir+args.bank_file

plot_folder = None
if args.show: args.plot = True
if args.plot: plot_folder = args.run_dir


	######
	#	Loading PSD, and creating an istance of metric (if it applies)
	######
if args.full_match or args.full_match_symphony: #in this case we need to load the PSD and instantiate the metric
		#load PSD
	f, PSD = load_PSD(args.psd, args.asd, args.ifo)

		#create metric
	metric = cbc_metric(PSD = (f, PSD), approx = args.approximant,
			f_min = args.f_min, f_max = args.f_max,
			variable_format = args.variable_format)

	######
	#	Loading the bank and instatianting a spin handler
	#	We also try to load a tile_id_population obj
	######
bank = cbc_bank(args.variable_format, args.bank_file)
print("Loaded bank {} with {} templates".format(args.bank_file, bank.templates.shape[0]))
var_handler = variable_handler()

t_obj = tiling_handler(args.tiling_file)

	#looking for an option al tile_id_population object saved in the out folder.
	#If there is None, no big deal: it will be created from scratch
tile_id_population_folder = os.path.dirname(args.bank_file)
if tile_id_population_folder == '': tile_id_population_folder = '.'

tile_id_population_file = [ f for f in os.listdir(tile_id_population_folder) if f.find('tile_id_population') != -1 ]
if len(tile_id_population_file) == 1:
	with open('{}/{}'.format(tile_id_population_folder,tile_id_population_file[0]), 'rb') as filehandler:
		tile_id_population = pickle.load(filehandler)
else:
	tile_id_population = None

	######
	#	Generating injections
	######

if args.inj_file is None:
		#generating tiles injections
	if args.seed is not None: np.random.seed(args.seed)
	projected_injs = [np.random.uniform(t[0].mins, t[0].maxes, (args.injs_per_tile, len(t[0].maxes))) for t in t_obj]
	projected_injs = np.concatenate(projected_injs, axis =0) #(N_tiles * inj_per_tile, D)
	
	#projected_injs = bank.templates; print("######### Bank injections!! ###########") #FIXME: this will become a bank-injs option!! Or something similar
	
	injections_full = np.array(var_handler.get_BBH_components(projected_injs, args.variable_format)).T
	del projected_injs #storing projected_injs is a waste of memory that can scale super badly
else:
	injections = []
	
		#loading injections from file and projecting them on the bank manifold
		#The injection fle can be either xml or json
	if args.inj_file.endswith('xml') or args.inj_file.endswith('xml.gz'):
		xmldoc = lw_utils.load_filename(args.inj_file, verbose = False, contenthandler = LIGOLWContentHandler)
		sim_inspiral_table = lsctables.SimInspiralTable.get_table(xmldoc)

		if args.N_inj is None: args.N_inj = len(sim_inspiral_table)
		if args.N_inj > len(sim_inspiral_table): args.N_inj = len(sim_inspiral_table)

		for i, row in enumerate(sim_inspiral_table):
			if i >= args.N_inj: break
			injections.append([row.mass1, row.mass2, row.spin1x, row.spin1y, row.spin1z, row.spin2x, row.spin2y, row.spin2z, row.inclination, row.coa_phase])
				
	elif args.inj_file.endswith('json'):
		with open(args.inj_file) as f:
			inj_json = json.load(f)
		
		if args.N_inj is None: args.N_inj = len(inj_json['items'])
		if args.N_inj > len(inj_json['items']): args.N_inj = len(inj_json['items'])
		
		for i, row in enumerate(inj_json['items']):
			if i >= args.N_inj: break
			injections.append([row['m1'], row['m2'], row['s_1x'], row['s_1y'], row['s_1z'], row['s_2x'], row['s_2y'], row['s_2z'], row['inclination'], 0.]) #You set phi arbitrarly!! Pay attention
	
		
	else:
		raise ValueError("Format for the input file for the injections must be either xml or json")
	
	print("Loaded {} injections from file: {}".format(args.N_inj, args.inj_file))
	injections_full = np.array(injections) #(N,10)

	######
	#	Computing tiling_injections with metric approximation
	#	Here injections are projected to the bank manifold
	######
injection_stat_dict = compute_metric_injections_match_bruteforce(injections_full, bank,  t_obj, N_neigh_templates = args.N_neigh_templates)

#injection_stat_dict = compute_metric_injections_match(injections_full, bank, t_obj,
#			N_neigh_templates = args.N_neigh_templates, N_neigh_tiles = args.N_neigh_tiles,
#			tile_id_population = tile_id_population)
#out_list = compute_avg_dist(bank, t_obj, metric)

	######
	#	Recomputing the match with the actual match and with the actual injections (non-projected)
	#	(if it's the case)
	######
if args.full_match or args.full_match_symphony:
	templates_full = np.array(var_handler.get_BBH_components(bank.templates, args.variable_format)).T #(N,10)
		#this function should take the stat_dict and for each best_id, it should replace the metric match with the actual match
		#The actual match shall be computed with metric.WF_match
		#The function returns an updated version of injection_stat_dict
	metric.set_variable_format('m1m2_fullspins_emeanano_iotaphi')

	best_matches_metric = np.array(injection_stat_dict['match'])

	if args.use_ray:
		injection_stat_dict = ray_compute_injections_match(injection_stat_dict, templates_full, metric,
				args.N_neigh_templates_full, symphony_match = args.full_match_symphony, cache = args.cache)
	else:
		injection_stat_dict = compute_injections_match(injection_stat_dict, templates_full, metric,
				args.N_neigh_templates_full, symphony_match = args.full_match_symphony, cache = args.cache)
	metric.set_variable_format(args.variable_format)
	
	######
	#	Writing to file
	######
save_name = os.path.basename(args.bank_file).split('.')[0]+'-tile_injections.pkl'

with open(args.run_dir+save_name, 'wb') as filehandler:
	pickle.dump(injection_stat_dict, filehandler)
	
	#to load... just in case
#with open(args.run_dir+save_name, 'rb') as filehandler:
#	injection_stat_dict = pickle.load( filehandler)


	######
	#	Making some plots
	######
if args.plot:
	
		#projecting over the template manifold
	projected_injs = var_handler.get_theta(injections_full, args.variable_format) #(N,D)
	
		#histogram for the overall match
	
	best_matches = injection_stat_dict['match']
	best_matches[best_matches<=0] = 0.01
	
	print("Matches percentiles [50, 5, 1]: ", np.percentile(best_matches, [50, 5,1]))
	
		###
		# Histogram
		###
	plt.figure()
	plt.title("Injection recovery for bank {}".format(os.path.basename(args.bank_file)))
	N_bins = 30
	logbins = np.logspace(np.log10(np.percentile(best_matches, [.5])[0]),np.log10(max(best_matches)), N_bins)
	plt.hist(best_matches, bins = logbins, density = True)
	if args.full_match or args.full_match_symphony: plt.hist(best_matches_metric, bins = logbins, histtype='step', density = True)
	
	if isinstance(args.MM, (float, int)): plt.axvline(x = args.MM, c = 'r') #DEBUG
	plt.xscale('log')
	#plt.show()
	plt.savefig(args.run_dir+'FF_hist.png', transparent = False)

	ids_to_plot = np.where(best_matches<np.percentile(best_matches, 50))[0]

		###
		# Colored plots
		###
	fig, axes = plt.subplots(projected_injs.shape[1]-1, projected_injs.shape[1]-1, figsize = (20,20))
	plt.suptitle("Injections for {} - points worse than the 50th percentile".format(os.path.basename(args.bank_file)))
	if projected_injs.shape[1]-1 == 1:
		axes = np.array([[axes]])
	for i,j in permutations(range(projected_injs.shape[1]-1), 2):
		if i<j:	axes[i,j].remove()
	
	for ax_ in combinations(range(projected_injs.shape[1]), 2):
		currentAxis = axes[ax_[1]-1, ax_[0]]
		ax_ = list(ax_)
		
		#fig = plt.figure()
		currentAxis.scatter(*bank.templates[:,ax_].T, s = 2, marker = 'x', c= 'r', alpha = 0.4)
		cbar_vals = currentAxis.scatter(projected_injs[ids_to_plot,ax_[0]], projected_injs[ids_to_plot,ax_[1]],
				s = 20, marker = 'o', c= best_matches[ids_to_plot])
		if ax_[0] == 0:
			currentAxis.set_ylabel(var_handler.labels(args.variable_format, latex = True)[ax_[1]])
		else:
			currentAxis.set_yticks([])
		if ax_[1] == projected_injs.shape[1]-1:
			currentAxis.set_xlabel(var_handler.labels(args.variable_format, latex = True)[ax_[0]])
		else:
			currentAxis.set_xticks([])
		
		for t in t_obj:
			d = t[0].maxes- t[0].mins
			currentAxis.add_patch(matplotlib.patches.Rectangle(t[0].mins[ax_], d[ax_[0]], d[ax_[1]], fill = None, alpha =1))
	
	cbar_ax = fig.add_axes([0.95, 0.15, 0.015, 0.7])
	fig.colorbar(cbar_vals, cax=cbar_ax)
	plt.subplots_adjust(wspace=0, hspace=0, bottom = 0.05, right = 0.92, left = 0.05, top = 0.97)
	plt.savefig(args.run_dir+'injections_scatter.png', transparent = False)
	
	if args.show: plt.show()





















	
	
	
